# Тестовое задание: Группировка и ранжирование по правилам (чистый PHP)

Тестовое задание для backend разработчика, сфокусированное на чистом Php. Оно сохраняет фокус на чистом PHP, с насыщенной
алгоритмической частью и проверяет умение работать с нестандартной логикой, вложенными структурами и эффективной обработкой данных — без использования фреймворков, БД или внешних зависимостей.

## Контекст:
Вы получаете список событий (например, действия пользователей на сайте): просмотры, клики, покупки. Каждое событие связано с пользователем и имеет тип и временную метку.

#### Вам нужно:
 1. Сгруппировать события по пользователям
 2. Найти «активных» пользователей по заданным бизнес-правилам 
 3. Построить ранжированный  отчёт

#### Входные данные
Через php://input поступает JSON в формате:

 

    {
      "events": [
        {
          "user_id": 101,
          "type": "view",
          "timestamp": 1712123400
        },
        {
          "user_id": 101,
          "type": "click",
          "timestamp": 1712123460
        },
        {
          "user_id": 102,
          "type": "purchase",
          "timestamp": 1712123500
        }
        // ... до 1000 событий 
      ]
    }

### Гарантии:
 - user_id — целое положительное число 
 - type — одна из строк: "view", "click", "purchase" 
 - timestamp — Unix-время

### Задача

Реализуйте скрипт report.php на чистом PHP, который:


 1. **Валидирует входные данные**
 - Проверяет, что events — массив 
 - Каждый элемент содержит все 3 поля правильного типа 
 - При ошибках — возвращает 400 Bad Request с JSON-сообщением
 
 2. **Для каждого пользователя вычислите:**
 - Общее число событий
 - Число уникальных дней активности (timestamp преобразовать в дату Y-m-d, посчитать уникальные)
 - Есть ли покупка ("purchase" в событиях?)
 - Есть ли последовательность "view -> click -> purchase" в течение 10 минут
 
**Это ключевая алгоритмическая часть.**

**Последовательность считается найденной, если:**

 - Существуют три события одного пользователя с типами "view", "click", "purchase"
 - Их временные метки идут в порядке возрастания 
 - Разница между первым (view) и последним (purchase) ≤ 600 секунд (10 минут)
 
3. **Отфильтруйте пользователей:**

Оставить только тех, у кого:

 - ≥ 2 уникальных дня активности
 - ИЛИ Есть успешная последовательность view -> click -> purchase в течение 10 мин

 - **Отсортируйте результат по приоритету:**

 - Сначала пользователи с успешной последовательностью (в порядке убывания user_id) 
 - Затем — остальные (по убыванию числа уникальных дней, затем по user_id)
 - **Верните JSON-ответ в формате:**

        {
        "qualified_users": [
            {
                "user_id": 101,
                "total_events": 5,
                "unique_days": 3,
                "has_purchase": true,
                "has_conversion_funnel": true
            },
            {
                "user_id": 105,
                "total_events": 8,
                "unique_days": 4,
                "has_purchase": false,
                "has_conversion_funnel": false
            }
        ]
    }

### Технические требования

 - Только чистый PHP (без фреймворков, без composer, без внешних библиотек) 
 - Используйте встроенные функции PHP (array_filter, usort,date, и т.д.)
 - Код должен быть читаемым и логически разбит на функции
 - Обработка до 1000 событий должна быть эффективной (O(n log n) или лучше) 
 - Все ошибки — через http_response_code(400) и JSON с полем "error"

**Это задание проверяет**

 - Работу с временными метками и датами 
 - Группировку и агрегацию данных
 - Алгоритмическое мышление (поиск последовательности с ограничением по времени) 
 - Навыки чистого PHP и обработки ошибок
